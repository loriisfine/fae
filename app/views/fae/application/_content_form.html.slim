ruby:
  require_locals     ['attribute', 'f'], local_assigns
  label              ||= attribute.to_s.titleize
  required           ||= f.object.send(attribute).is_required?(f.object.class)
  helper_text        ||= ''
  markdown           ||= false
  markdown_supported ||= false
  hint               ||= nil
  options            ||= {}
  input_options      ||= {}

  label_adjusted = required ? '<abbr title="required">*</abbr> ' : ''
  label_adjusted += label
  if markdown_supported.present? || helper_text.present?
    label_adjusted += content_tag :h6, class: 'helper_text' do
      concat(helper_text) if helper_text.present?
      concat(content_tag(:span, 'Markdown Supported', class: 'markdown-support')) if markdown_supported.present?
    end
  end

  options.merge! label: label_adjusted.html_safe, hint: hint
  options.merge! input_options if (input_options.keys).any?
  options.merge! wrapper_html: {} if input_options[:wrapper_html].blank?

  if options[:input_html].present? && options[:input_html][:class].present? && markdown.present?
    options[:input_html][:class] = options[:input_html][:class] + ' js-markdown-editor'
  else
    options.merge! input_html: {}
    options[:input_html].merge! class: 'js-markdown-editor' if markdown.present?
  end

= f.simple_fields_for attribute.to_sym, defaults: { wrapper_html: options[:wrapper_html] } do |i|
  - options[:input_html].merge! data: { validate: i.object.validation_json(f.object.class) }
  = i.input :content, options

